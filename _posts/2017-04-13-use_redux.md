---
layout: post
title: 【翻译】在 react 中使用 redux
published: true
categories: 翻译 react redux
tags: 无
---

# 【翻译】在 react 中使用 redux

> 原文地址： http://codepen.io/stowball/post/a-dummy-s-guide-to-redux-and-thunk-in-react

如果你像我一样，在读了 [redux 文档](https://redux.js.org)、看过了 [Dan's 教学视频](https://egghead.io/courses/getting-started-with-redux)、完成了 [We's 课程](https://www.learnredux.com/)，还是没有搞明白如何使用 redux，那么希望这个能够帮到你。

在我试用过好几次的 redux 后才理解了 redux 的用法，将一个从 ajax 接口接收 json 数据的应用改变成使用 redux/redux thunk 的模式。
因此我觉得应该将此过程记录下来，如果你不懂什么是 thunk，那也别着急，我们将在 “Redux way” 的异步调用中使用到它。

此篇文章假设你已经有了 react 和 ES6 的基础，掌握这些应该也是比较简单的。

## 非 Redux 模式

我们先来写一个 react component：`components/ItemList.js`，调用一个接口获取列表数据。

### 基础内容

首先，我们在 `state` 中设置一些静态的数据：包括主要显示内容的 `items`，还有两个 boolean 标识用来区分正在加载和加载错误时的渲染内容。

~~~javascript
import React, { Component } from 'react';

class ItemList extends Component {
    constructor() {
        super();

        this.state = {
            items: [
                {
                    id: 1,
                    label: 'List item 1'
                },
                {
                    id: 2,
                    label: 'List item 2'
                },
                {
                    id: 3,
                    label: 'List item 3'
                },
                {
                    id: 4,
                    label: 'List item 4'
                }
            ],
            hasErrored: false,
            isLoading: false
        };
    }

    render() {
        if (this.state.hasErrored) {
            return <p>Sorry! There was an error loading the items</p>;
        }

        if (this.state.isLoading) {
            return <p>Loading…</p>;
        }

        return (
            <ul>
                {this.state.items.map((item) => (
                    <li key={item.id}>
                        {item.label}
                    </li>
                ))}
            </ul>
        );
    }
}

export default ItemList;
~~~

这看起来不太像是一个非常漂亮的开局，但至少是算是好的。

当渲染完毕后，component 会展示出这4个列表元素，如果你将 `isLoading` 或 `hasErrored` 置成 true，一个对应的 `<p>` 会替代列表显示 。

### 改成动态组件 

把这些元素都写死的话，这个 component 肯定没法用的，so 我们需要从一个 json api 中获取 `items` 数据，同时也需要我们在适当的时候将 `isLoading` 或 `hasErrored` 正确的置位。

接口提供的 `items` 数据和我们造的是完全一致的，当然在真实情况下，它可能是一个畅销书的列表、一个最新的博文列表，或是其它符合你业务场景的数据。

获取数据我们用 [fetch](https://developer.mozilla.org/en/docs/Web/API/Fetch_API)，`fetch` 使用起来比传统的 `XMLHttpRequest` 更方便，而且返回的 response 结果是一个标准的 `promise` 对象（这对于 Thunk 模式非常重要）。
`fetch` 无法在所有浏览器中得到支持，所以你需要在项目中安装以下组件：

~~~shell
npm install whatwg-fetch --save
~~~

开始转换这一部分，非常简单：

1. 将初始的 `items` 置成一个空的数组；
2. 添加获取数据的方法和控制 `isLoading` 和 `hasErrored` 的状态：

~~~javascript
fetchData(url) {
    this.setState({ isLoading: true });

    fetch(url)
        .then((response) => {
            if (!response.ok) {
                throw Error(response.statusText);
            }

            this.setState({ isLoading: false });

            return response;
        })
        .then((response) => response.json())
        .then((items) => this.setState({ items })) // ES6 property value shorthand for { items: items }
        .catch(() => this.setState({ hasErrored: true }));
}
~~~

3. 在组件加载完毕后我们调用它；

~~~javascript
componentDidMount() {
    this.fetchData('http://5826ed963900d612000138bd.mockapi.io/items');
}
~~~

此时内容如下：(省略没有变的内容)

~~~javascript
class ItemList extends Component {
    constructor() {
        this.state = {
            items: [],
        };
    }

    fetchData(url) {
        this.setState({ isLoading: true });

        fetch(url)
            .then((response) => {
                if (!response.ok) {
                    throw Error(response.statusText);
                }

                this.setState({ isLoading: false });

                return response;
            })
            .then((response) => response.json())
            .then((items) => this.setState({ items }))
            .catch(() => this.setState({ hasErrored: true }));
    }

    componentDidMount() {
        this.fetchData('http://5826ed963900d612000138bd.mockapi.io/items');
    }

    render() {
    }
}
~~~

你的组件通过一个 `REST` 端获取数据，我们希望在`items`获取之前能够看到一个简单的 `loading...` 。
如果接口获取失败，也应该有一个相应的错误提示。

然而，在现实情况下，一个 `component` 不应当包括抓取数据的逻辑，数据也不应当存储在 `component` 的 `state` 中，
这个时候， **Redux** 就应声而来了。

## 转换成 Redux 模式

### 理解 Redux

在这之前，我们需要理解几个 Redux 的核心原则：

1. 有一个全局的 `state` 来控制整个应用的各个 `state`，在这个例子中，它的作用和我们初始化 state 的行为是一致的，就是所谓的‘真相只有一个’；
2. 唯一改变 state 的方法就是通过引入的 action，它是一个描述哪个数据应当被修改的对象（方法）。Action Creators 是一些 `function`，它们被用来发起这些改变，所作的就是返回一个 action；
3. 当一个 action 被发起，reducer 就上场了，它会根据相关的 action 改变真实的 state 属性，或是当这个 action 不适用与这个 reducer 时，返回当前的 state；
4. reducer 应该是一个“纯函数”，不应当对传入的 state 产生任副作用，或是改变 state 本体，它应该返回一个修改后的副本；
5. 单个的 reducer 被合并成一个 rootReducer，从页产生出那些互不相关的 state 属性；
6. Store 的作用是将这些整合到一块去，它通过 `rootReducer` 方法和任何中间件来表示状态（在本例中为Thunk），并允许您 `dispatch` action；
7. 在 React 中使用 Redux，`<Provider />` 包裹了整个的应用，并且将 `store` 向下传递给在子结点；

随着我们将项目转换成使用 `redux` 的模式，这些原则也将变得更加清晰。

### 设计我们的 state

从我们已经完成的那些内容来看，认识到我们的 state 需要3个属性：`items`, `hasErrored` 和 `isLoading`，这样它就能在我们所预期的所有情况下工作了，因此，我们也需要三个相关的 action。

到这里，需要说明为什么 Action Creators 和 Actions 不一样，而且也不是 1对1 的关系：我们需要第四个 actions Creator，来根据我们所获取到的数据结果调用其它3个不同的 action。
这第4个 action creator 基本上和我们原始的 `fetchData()` 方法作用是一致的，但是它不会直接显式的调用 `this.setState({ isLoading: true })` 来改变组件的 state，而是 `dispatch` 一个 action 来作这件事：`dispatch(isLoading(true))`。

### 编写 action

我们来写一个 `actions/items.js`，作为 action creators，我们从三个简单的方法开始：

~~~javascript
export function itemsHasErrored(bool) {
    return {
        type: 'ITEMS_HAS_ERRORED',
        hasErrored: bool
    };
}

export function itemsIsLoading(bool) {
    return {
        type: 'ITEMS_IS_LOADING',
        isLoading: bool
    };
}

export function itemsFetchDataSuccess(items) {
    return {
        type: 'ITEMS_FETCH_DATA_SUCCESS',
        items
    };
}
~~~

如前面所述，action creator 返回的是 action。
我们将每个方法 export，这样就可以代码库任何地方来使用它。

前两个 action creators 将 boolean 值作为参数，同时返回一个对象，对象包括一个特定字符串的 type，和对应属性的 bool 值。

第三个方法 `itemsFetchSuccess()` 将会在数据成功获取后调用，同时将所需的数据作为 `items` 进行传递，
利用 es6 "property shorthands" 的特性，我们可以将 `items` 赋值给名称同为 `items` 的属性。

> 注意：你所用到的 type 的值和你需要返回的 property 属性名是非常重要的，因为你还要在 reducer 中用到它。

现在，我们已经有了3个 action 来表示所谓的 state, 现在我们来修改原有的 `fetchData` 方法，转换成 `itemsFetchData()` action。

默认情况下，Redux action creators 不支持像 `fetch` 这样的异步数据，因此，在这里我们需要使用 redux thunk 模式。
Thunk 允许你编写一个返回 function 的 action creators，而不是返回一个对象。
这个内部函数可以接收 store 方法中的 dispatch 和 getState 作为参数，但是我们只使用 dispatch。

举个简单的例子，比如是在5秒后手动触发 `itemsHasErrored()`。

~~~javascript
export function errorAfterFiveSeconds() {
    // We return a function instead of an action object
    return (dispatch) => {
        setTimeout(() => {
            // This function is able to dispatch other action creators
            dispatch(itemsHasErrored(true));
        }, 5000);
    };
}
~~~

现在我们知道什么是 thunk 模式了，如此，我们就可以编写 `itemsFetchData()` 了。

~~~javascript
export function itemsFetchData(url) {
    return (dispatch) => {
        dispatch(itemsIsLoading(true));

        fetch(url)
            .then((response) => {
                if (!response.ok) {
                    throw Error(response.statusText);
                }

                dispatch(itemsIsLoading(false));

                return response;
            })
            .then((response) => response.json())
            .then((items) => dispatch(itemsFetchDataSuccess(items)))
            .catch(() => dispatch(itemsHasErrored(true)));
    };
}
~~~

## 编写 reducers

(全文较长，下期继续。。。)