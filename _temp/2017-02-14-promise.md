---
layout: post
title: js 异步代码同步化处理之 promise
---

# promise 由浅入深

首先说一下 “由浅入深” 这个词用的过了，一般说到这个词就已经是可以出书的概念了。
这里的 “由浅入深” 只是一个意愿，也是从出了这个特性就一直用到现在的一些个人小总结。在这里记录下来。

## 背景由来

要说到 JS 和其它语言相比，直观上最“大”(*注1)的特征，也就算是异步回调了。
但是这种回调在编程写法上很不友好，一两个回调还好，一但多起来、尤其是相互套用，这就很“难看”了，也出现了所谓的 “callback hell” 回调地狱。
这种情况对一些逻辑实现和模块设计上都很别扭。

这个时候，就出现了一些解决此类问题的方法，到现在，成为公认解决方案的就是 promise 规范。

## 基础解释

promise 在用一种链式调用的方式，从形式上解决了回调嵌套调用的问题。当然，这只是形式上，因为是 JS 运行机制的问题，无法从根本上解决。

看下面的例子：

~~~javascript
/**
 * 根据用户ID获取用户信息
 * @param uid 用户id
 * @callback 回调方法
 */
function (uid, callback) {
    $.ajax({
        url: '/user/info',
        data: {uid: uid},
        dataType: 'json',
        success: function (data) {
            callback({
                data: data,
                status: 'success',
                message: ''
            });
        },
        error: function (err) {
            callback({
                data: null,
                status: 'success',
                message: err.state
            });
        }
    });
}
~~~

这是一个很典型的异步请求回调的方法，因为 request 请求是异步的，方法执行完不能像同步执行那样直接 `return` 一个数据，所以一般只能是再传入一个回调方法作为参数来接收处理数据。

这样在方法、模块拆分上就很不直观了。这个时候，`promise` 就出现了，它可以从代码字面上去掉回调方法的参数，返回『结果数据』。

~~~javascript
/**
 * 根据用户ID获取用户信息
 * @param uid 用户id
 * @return 用户数据
 */
function getUserinfo(uid) {
    return new Promise(function (resolve, reject) {
        $.ajax({
            url: '/user/info',
            data: {uid: uid},
            dataType: 'json',
            success: function (data) {
                resolve({
                    data: data,
                    status: 'success',
                    message: ''
                });
            },
            error: function (err) {
                reject({
                    data: null,
                    status: 'success',
                    message: err.state
                });
            }
        });
    });
}
~~~

这个终于有 `return` 了，从代码易读性和维护性上已经有很大程序的提高，虽然它并没有实际解决回调问题，看用法：。

~~~javascript
var userinfo = getUserinfo('U123321');
userinfo.then(function (data) {
    /*
    {
        data: data,
        status: 'success',
        message: ''
    }
     */
}).catch(function (err) {
    /*
    {
        data: null,
        status: 'success',
        message: err.state
    }
     */
});
~~~

> 注1：这种特性现在已经不存在了，基本上现有成熟的语言都有了自己的异步执行方式和“事件”回调


