<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset='utf-8'>
        <meta http-equiv="X-UA-Compatible" content="chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <title>MVC 架构简介</title>
        <link rel="stylesheet" href="/css/stylesheet.css" media="screen">
        <link rel="stylesheet" href="/css/flexbox.css">
        <link rel="stylesheet" href="/css/github-gist.css">
        <!--[if lt IE 9]>
        <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
        <script src="/js/jquery-1.11.3.js"></script>
        <script src="/js/highlight.pack.js"></script>
    </head>
    <body>
        <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
            <a id="forkme_banner" href="https://github.com/yj1438">View on GitHub</a>

            <h1 id="project_title">Yinjie - GitHub.io</h1>
            <h2 id="project_tagline">Yinjie - GitHub.io</h2>

        </header>
    </div>
        
    <div id="content-wrapper">
        <div class="main clearfix">
            <aside id="sidebar">
                <ul class="side-nav">
                </ul>
            </aside>

            <section id="main-cont">
                <h1 id="mvc-">MVC 架构简介</h1>

<blockquote>
  <p>MVC 是一个软件框架模式。自从 1982 被提出至今，MVC 一直存在于软件行业的各个领域，
为整个软件的基础架构设计、层级设计、模块划分、代码组织逻辑等等行为提供有力的理论支持</p>
</blockquote>

<h2 id="section">知识背景</h2>

<p>上世纪 80 年代初，全球图形界面软件快速发展，在软件规模不断变大的情况下，需要一种明确的软件框架模式对大中型软件进行合理规划。
Xerox PARC 提出了 <strong>模型－视图－控制器（MVC）</strong> 模式，进行框架层级的划分和代码上的分离。</p>

<p><img src="/img/mvc/1.png" alt="MVC frame" /></p>

<p>MVC 提出后被各个图形软件广泛采用。因其具有清晰的逻辑层次和优秀的工程管理性质，被企业软件巨头之一的 Oracle 用在了 J2EE 平台软件的设计模式上。
随着 J2EE 的兴盛和软件面向对象设计的普通采用，MVC 的思想在软件各个领域都大放异彩。</p>

<h2 id="section-1">框架思想哲理</h2>

<blockquote>
  <p>写书是人类表达和展示自己的思想的重要方式</p>
</blockquote>

<p>在老老年间，古人们写书或复制书就只能用手写，直接将字手写在纸上。数据的来源和展现都通过纸面这唯一中间过程。行为不可完全复制。</p>

<p><img src="/img/mvc/2.jpg" alt="MVC frame" /></p>

<p>后来，活字印刷术的出现将上述过程进行统一标准化。将整个过程划分为三部分： </p>

<p><img src="/img/mvc/3.jpg" alt="MVC frame" /></p>

<ul>
  <li>统一的、持久化的数据源：活字 （Model）;</li>
  <li>标准化的业务逻辑过程：排版 （Controller）;</li>
  <li>纯粹的渲染展示：印刷 （View）;</li>
</ul>

<p>如此一来，整个印刷过程根据侧重点的不同分为三部分。每一部分在业务上能够做到相对独立，复用程度提高，后期的维护也简单不少。</p>

<p>MVC 的思想其实在我们生活的各个方面都有展现。将普通作业进行工程化改造，有利于作业过程管理，思维上更加清晰明确。提高工作效率和后期维护度。</p>

<h2 id="mvc--1">MVC 在软件框架上的具体体现</h2>

<p>（以 babytree 为例，简单说一下 MVC 在软件系统前后台的体现）</p>

<p>（。。。）</p>

<h3 id="bbt--mvc-">bbt 后台 MVC 简要说明</h3>

<h4 id="section-2">文件组织结构</h4>

<ul>
  <li>Controller : <code>baby/classes/Babytree/Controllers</code></li>
</ul>

<p><img src="/img/mvc/5.png" alt="MVC frame" /></p>

<blockquote>
  <p>例如一个 Controller 文件 baby/classes/Babytree/Controllers/<strong>XXX/indexController.php</strong>  </p>
</blockquote>

<pre><code class="language-php">class indexController extends WebSiteController {
    
    /**
     * 这是一个 action 
     * 对应的 url /XXX/index/index
     */
    public function indexAction() {
        //组织一些数据
        $data = array(
            type =&gt; '前端',
            lessons =&gt; array(
                'javascript',
                'css',
                'html'
            ),
            other =&gt; null
        );
        //将相关数据输出到页面上
        $this-&gt;assign('data', $data);
        //选择模板进行渲染
        return $this-&gt;htmlView('tmpl/XXX/index_tpl.php');
    }
    
}
</code></pre>

<ul>
  <li>View : <code>baby/tmpl</code></li>
</ul>

<p><img src="/img/mvc/4.png" alt="MVC frame" /></p>

<blockquote>
  <p>和上面 Controller 对应的模板文件 baby/tmpl/<strong>XXX/index_tpl.php</strong>  </p>
</blockquote>

<pre><code class="language-html">&lt;section&gt;&lt;h1&gt;你需要掌握什么核心专业知识?&lt;/h1&gt;
    &lt;div&gt;你是&lt;span&gt;&lt;?php echo $data['type']?&gt;&lt;/span&gt;工程师&lt;/div&gt;
    &lt;ul&gt;
        &lt;?php foreach($data.lessons as $i =&gt; $v){?&gt;
        &lt;li anchor="lessons"&gt;&lt;?php echo $v?&gt;&lt;/li&gt;
        &lt;?php }?&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;label&gt;还有补充的吗？&lt;input type="text" value="&lt;?php echo $data['other']?&gt;"&gt;&lt;/label&gt;&lt;/p&gt;
    &lt;p&gt;&lt;textarea style="width: 300px;" rows="5" placeholder="总结一下学习计划"&gt;总结一下吧&lt;/textarea&gt;&lt;/p&gt;
&lt;/section&gt;
</code></pre>

<ul>
  <li>Model : <code>baby/classes/Babytree/Models</code></li>
</ul>

<p><img src="/img/mvc/6.png" alt="MVC frame" /></p>

<blockquote>
  <p>Model 中主要是业务中抽象出来的数据模型，比如以上的</p>
</blockquote>

<pre><code class="language-php">class Model {
    
    function __construct() {
        $this-&gt;type = '前端';
        $this-&gt;lessons = array(
            'javascript',
            'css',
            'html'
        );
        $this-&gt;other = null;
    }
}

//用 new Model() 可以获得一个数据实例
</code></pre>

<p>从数据到视图的流程大致如下：</p>

<p><img src="/img/mvc/lichen.png" alt="MVC frame" /></p>

<h3 id="mvc--2">主流前端框架的 MVC 简要分析</h3>

<p>下面，以 <code>backbone</code>、 <code>angularjs 1</code>、 <code>reactjs</code> 为例，简要说明一下当 MVC 做为前端的一个新兴的事物，是如何被我们所利用的。</p>

<hr />

<h4 id="backbone">Backbone</h4>

<p>Backbone 框架是三者中最简练，但是最标准的 MVC 前端框架。</p>

<h5 id="section-3">基本特性</h5>

<p><img src="/img/mvc/backbone.png" alt="MVC frame" /></p>

<p>backbone 的中文字面翻译叫 “脊椎” 。如其名，它本是框架特性就是提供了一个明确的结构划分，有良好的扩展性，没有添加过多的“自动化”方法。强依赖 <code>Underscore</code> 、<code>jquery</code>/<code>zepto</code>，从中你可以使用依赖库所提供的方法，比如<code>this._</code>、<code>this.$</code>。</p>

<blockquote>
  <p>注意：在 backbone 类的内部调用 jquery：<code>this.$</code> 有 dom 控制域的限制，这也许被很多刚开始接触的人认为这是一个坑，实际上这个限制正是 backbone 在模块划分上的一种规范，backbone 建议由此来限制用户在控制器内只对 <code>el</code> 中指定的 dom 元素进行操作，强制用户进行更好的模块划分。</p>
</blockquote>

<p>你会发现上图中缺少 “视图” 元素，这也体现了 backbone 的灵活性，它没有自带的模板引擎，你可以使用依赖库 <code>Underscore</code> 的 <code>_.template("———模板内容———")</code> 作为模板引擎，也可以使用其它的模板引擎。</p>

<pre><code class="language-javascript">AppView = Backbone.View.extend({
    el: '#appele',
    template: _.template('&lt;p&gt;这是一个模板内容&lt;br&gt;&lt;span style="font-size: 30px;"&gt;&lt;%=value%&gt;&lt;/span&gt;&lt;/p&gt;'),
    initialize: function() {
        this.model = new Model();
        this.listenTo(this.model, 'add', this.render);
    },
    render: function() {
        this.$el.append(this.template({value: '哈哈'}));
        this.$('.dom').show();
    }
})
</code></pre>

<h5 id="section-4">（视图）模板渲染原理</h5>

<p>backbone 是弱单向的数据绑定框架，你只能手动的将所需的数据事件绑定到指定的 Model 上，完全没有视图端的数据变化监听，也不去管数据变化后视图怎么变。它把 render 方法抛给了用户，完全由用户决定怎么弄。<br />
backbone 官方实际引导大家使用一个 简单、粗暴、有成效 的方式，就是 <strong>整个重新渲染</strong> ，而不是“细致”的根据变化的数据来去操作 DOM 一个一个的改。<br />
这实际也是 MVC 的一个核心思想：<strong>数据驱动</strong> — 用户不应该直接操作视图，应该把重心放到数据和业务逻辑上来。</p>

<blockquote>
  <p>注：<strong>整个重新渲染</strong> 在很多情况下并不粗暴，也是有性能考虑的根据的，dom 的频繁改动是页面性能的一个痛点，与其改10个，不如一次换1个，除非你能做到极致。</p>
</blockquote>

<hr />

<h4 id="reactjs">reactjs</h4>

<p>reactjs PS: 我在这里是充数的，其实，我只是个 UI 。  </p>

<blockquote>
  <p>JUST THE UI<br />
Lots of people use React as the V in MVC. Since React makes no assumptions about the rest of your technology stack, it’s easy to try it out on a small feature in an existing project.</p>
</blockquote>

<h5 id="section-5">基本特征</h5>

<p>如果说 “正规” 的 MVC 概念重心是进行层级的横向划分，那么 reactjs 的核心概念 Component 则提供一种(页面)模块的纵向划分思想。  </p>

<p><img src="/img/aaa/vh.png" alt="v or h" /></p>

<p>举个例子，大家手头有这样一个页面</p>

<pre><code class="language-html">&lt;body&gt;
    &lt;header&gt;
        ...&lt;!-- 此处省去50行 and 其它页面也用--&gt;
    &lt;/header&gt;
    
    &lt;aside&gt;
        ...&lt;!-- 此处省去300行 --&gt;
    &lt;/aside&gt;
    
    &lt;section&gt;
        ...&lt;!-- 此处省去500行 --&gt;
    &lt;/section&gt;
    
    &lt;footer&gt;
        ...&lt;!-- 此处省去30行 and 其它页面也用 --&gt;
    &lt;/footer&gt;
&lt;/body&gt;
</code></pre>

<p>这么“庞大”的一个页面，你会怎么分隔，也许你会说，可以用 php 把它折开啊~那么用前端的技术和方法呢？</p>

<blockquote>
  <p>其实，php 和 java 的一些模板引擎早已做到这一步了，而且有着很好的实用性。现在需要用前端的技术完成“前端”的工作。</p>
</blockquote>

<p>现在有了 react 提供的页面组件化方式，你就不用把这么繁多的标签挤在一个页面里了。你的入口主页真的会变成这样:</p>

<pre><code class="language-html">&lt;body&gt;
    &lt;MyHeader /&gt;
    
    &lt;MyAside /&gt;
    
    &lt;MySection /&gt;
    
    &lt;MyFooter /&gt;
&lt;/body&gt;
</code></pre>

<p>你只需要在主页面（JS）中 “引入” 每一块的的 JS ，就是会得到你想要的结果，页面包含完整的功能与样式哦。就像这样:</p>

<p><strong>index.jsx</strong> </p>

<pre><code class="language-javascript">//react
import React from 'react';
//各个页面模块
import MyHeader from './MyHeader';
import MyAside from './MyAside';
import MySection from './MySection';
import MyFooter from './MyFooter';
//整体需要的样式
import './style/reset.less';
import './style/layout.less';

class Index extends React.Component {
    render() {
        return (
            &lt;div&gt;
                &lt;MyHeader /&gt;
                &lt;MyAside /&gt;
                &lt;MySection /&gt;
                &lt;MyFooter /&gt;
            &lt;/div&gt;
        )
    }
}

export default Index;
</code></pre>

<p><strong>mySection.jsx</strong></p>

<pre><code class="language-javascript">//react
import React from 'react';
//MySection 模块中需要的样式
import './style/my_section.less';

class MySection extends React.Component {
    render() {
        return (
            &lt;section&gt;
                ...&lt;!-- 此处省去500行 --&gt;
            &lt;/section&gt;
        )
    }
}

export default MySection;
</code></pre>

<p>通过 react 制作的每一个模块都是独立的，你不用再去纠结一个模块的 HTML结构、样式、JS脚本怎么分别弄进来，webpack 的强大的打包能力最终生成的文件肯定让你满意—当然这得自己去配置。</p>

<h5 id="mvc--3">MVC 特性</h5>

<p>从总体框架上来看，虽说 react 不是一个 MVC 框架，但其内在方法的划分和设计原理还是有明显的 MVC 思想。</p>

<p><strong>state</strong> 和 <strong>render</strong>。react 在数据和视图的关系上采用单向数据绑定的数据驱动模式，也就是数据模型和视图是一一对应的，不过数据改动后视图不一定立刻跟着变化，而是需要你自发的用 <strong>setState</strong> 去触发视图内容更新。</p>

<p>但是 react 不像 backbone 那么懒，把渲染视图的过程也抛给用户，react 有自己的一套非常先进的视图渲染系统—基于虚拟 dom 的最少改动方案。大致过程如下图：</p>

<blockquote>
  <p>注：策略上的区别对待是看 dom 更新的情况来确定是重新刷一遍、修改内容、还是替换等</p>
</blockquote>

<p>相比 backbone reactjs 就是算是把“DOM 操作”精细化到极致的人，我们最终看到的页面上的东西，不是完全真实的，而存在在内存里的 虚拟DOM 某种意义上才是和你的数据模型完全对应的 dom。</p>

<blockquote>
  <p>再说一次，mvc 是一种思想，再优秀的 MVC 框架</p>
</blockquote>

<hr />

<h4 id="angular">angular</h4>

<p>angular 框架是三者中最大，当然也是最 “强” 的 MVC 前端框架。</p>

<h5 id="section-6">基本特性</h5>

<p>angular 本质上是一个 MVVM 框架，也就是 <strong>数据模型-视图</strong> 双向绑定框架，自己就能提供框架所需的全部功能，当然你也可以再加入其它 js 类库，不过那之前我建议你还是先去认真找一找 angular 是否已经有了 -_-。</p>

<p>从 MVC 的基本要点出发，这里简要说一下以下几种模块类型：</p>

<p><img src="/img/mvc/angular.png" alt="angular" /></p>

<p>任何一个 WEB 应用框架的主要流程大概都是这样的：</p>


            </section>
        </div>
    </div>
        
    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
        <footer class="inner">
            <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
        </footer>
    </div>
    <script src="/js/aside-nav.js"></script>
    <script>
        hljs.initHighlightingOnLoad({useBR: true});
        $(document).ready(function() {
            $('pre code').each(function(i, block) {
                hljs.highlightBlock(block);
            });
        });
    </script>
    </body>
</html>